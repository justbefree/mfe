(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{399:function(t,e,r){"use strict";r.r(e);var n=r(51),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"背景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),r("p",[t._v("随着前端功能越来越丰富，面临的一个棘手问题就是如何通过"),r("text-yellow",{attrs:{txt:"模块共享"}}),t._v("来实现代码复用以及减少打包体积。目前我们通用的做法就是通过把公用的包发布到npm，然后将包安装到项目内，在通过webpack构建上线\n"),r("img",{attrs:{src:t.$withBase("/imgs/npm.png")}}),t._v("\n这样仅仅解决了代码共享的问题，但是项目变得越来越大会导致打包的速度越来越慢，以及打包后的体积也越来越大。你可能会说，项目大了就拆分嘛，把一个大的项目拆分成N个独立的子项目，子项目独立打包，更解耦，问题是拆分打包就没法抽取公共部分。更重要的是，对于用户来说多个项目之间切换在体验上会大打折扣。怎么办呢？")],1),t._v(" "),r("h2",{attrs:{id:"模块联邦-module-federation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块联邦-module-federation"}},[t._v("#")]),t._v(" 模块联邦（module federation）")]),t._v(" "),r("img",{attrs:{src:t.$withBase("/imgs/federation.png")}}),t._v(" "),r("p",[t._v("从图中可以看到，模块联邦的方式就是把一个应用的包提供给另一个应用直接使用，并且同时兼顾了公共包抽取的能力。换句话说，模块联邦提供了一种能力，让每个应用能独立输出对外暴露包，并且这个包是在线提供的，也即runtime运行时。")]),t._v(" "),r("p",[t._v("下面这张图也许看的更直接一点\n"),r("img",{attrs:{src:t.$withBase("/imgs/mfe.png")}}),t._v("\n一个应用由来自多个应用对外暴露包的集合")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/b5Gl_1yX1enktU9oulO9zg",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);